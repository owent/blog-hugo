---
author: owent
categories:
  - Article
  - Blablabla
date: 2018-05-28 20:23:31
draft: true
id: 1807
tags: 
  - atsf4g
  - atframework
  - 服务器
  - 框架
title: atsf4g-co的进化：协程框架v2和自适应栈池、对象路由系统
type: post
---

# 前言

年前就计划把以前项目的一些理念和设计方案融合到sample里来。但是内容比较多，一直也没太多时间去完成它。所幸虽然断断续续但终归是完成了。并且在之前的一些实现上还做了一些细节的优化。内容比较多我感觉我自己写的也比较乱，仅当作一个参照和小计吧。

# 协程系统优化

本来想直接写这里，但是写着写着有点长，就专门开了一篇，顺便补了和同类库的性能对比。详见: https://owent.net/2018/1806.html

# 对象路由

之前给我的上一个项目设计了对象路由系统，但是直到最近才有时间整理抽象并优化一下合入到 [框架sample][2] 里来。 原来的路由系统的设计见 https://owent.net/2017/1342.html 。

设计对象路由系统的主要目的：其一是统一游戏中不同类型的对象的续期、降级/升级、自动保活、定时保存的功能，这样不需要每种类型都单独实现一遍。当然因为游戏对象的种类非常多，要适应性足够好，就不得不加一些约定，暴露比较多的接口，也导致接入的复杂度稍微高一些；其二是统一转发消息给某个对象时，能够自动发送到对象负载均衡或是容灾、扩容、缩容后所在的节点，并且统一这个流程。

一般像数据库都是行级sharding或者行+部分列sharding的，类型和业务比较单一，而游戏对象就比较复杂。比如公会服务，可加入、可退出、可踢出、可管理还有很多其他游戏业务的逻辑。而且每种不同类型的游戏需要分片的对象差异都很大。在以前的一些解决方案中，有按Hash去静态路由到某些服务节点上，如果这个节点挂了会导致分到这个节点上的对象的服务都暂时不可用。而且扩容或者缩容的时候，需要暂停服务，不然数据迁移过程中可能会在新节点拿到迁移数据前收到服务请求，又或是在老节点已经移交对象数据出去后又收到该对象的服务请求。而使用路由系统就不存在这样的问题，如果某个节点出现故障一段容忍时间后可以自动迁移到可用节点进行服务，而后这个对象的所有服务消息会被转发到新的节点上。扩容和缩容的时候也可以不停服，只要数据转移完了，所有消息都会被转发到新节点上。整体结构的设计思路有点像Redis Cluster（详见： https://redis.io/topics/cluster-spec ）的结构，但是实现和流程细节有一些差异。

之前介绍过这个对象路由系统的设计了，这里就不重复了，着重说一下在之前的设计上进一步的优化。

## 优化一： IO排队自动化

第一个优化是IO自动排队。所谓IO就是读取和保存的任务。在之前的设计中，如果缓存不存在的时候同时来多个消息，则会拉取多次。虽然多次取回后会丢弃冗余的数据，逻辑上不会有问题，但是还是不必要地发起了拉取请求。

![1807-01.png](1807-01.dot.png)

当然，如果路由缓存本身就存在，就也不需要拉取，直接回并行执行所有的任务。

![1807-02.png](1807-02.dot.png)

同时在保存地时候的次序也是依赖了数据库层的顺序。而这里的IO自动排队就是解决这个问题，在拉取和保存的时候收敛到一处，并且还可以自动合并保存版本。

![1807-03.png](1807-03.dot.png)

比如上面所示的流程里，针对于某个对象，Task 2和Task 3在准备保存的时候Task 1在执行保存任务，那么Task 2和Task 3会等Task 1返回后再次执行保存。这时候因为Task 2和Task 3的数据都已经更新了，所以只需要保存一次最新的数据到数据库，就同时保证了Task 2和Task 3的保存都成功完成。这种情况下就产生了一次数据的Merge并且减少了一次保存开销。

## 优化二： 快队列

我们在路由系统设计了一个全局定时器管理器，统一管理对象的超时降级、定时保存和缓存淘汰问题。但是当定时器触发的时候可能这个对象正处于某种操作中，比如正在执行IO操作而不能立刻降级或者移除，这时候我们回尝试重新将其插入到下一轮定时器中。但是原先只有一种定时器，也就是下一次定时器操作可能是几分钟以后了。所以这里我又加了一个块队列，这种情况下只要等待很短的时间后就可以重试了。这样可以加快出现冲突时的资源回收。

# 设计细节优化

## 调度系统优化
不再需要全局container

## 统一异步指令流程

## etcd接入抽象层

## hostname判定优化

## simulator的优化和配置的时间单位
定时器机制、exec_cmd代替insert_cmd

# 优化方向

[1]: https://github.com/atframework/atsf4g-co/
[2]: https://github.com/atframework/atsf4g-co/tree/sample_solution
[3]: https://github.com/owt5008137/libcopp
[4]: http://en.cppreference.com/w/cpp/concept/TrivialType
[5]: https://github.com/yyzybb537/libgo
[6]: https://github.com/Tencent/libco
[7]: https://golang.org/
[8]: https://golang.org/dl/#go1.10.2
[9]: https://www.boost.org/
[10]: https://www.boost.org/users/history/version_1_67_0.html