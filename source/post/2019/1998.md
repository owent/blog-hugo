---
author: owent
categories:
  - Article
  - Blablabla
date: 2019-12-11 22:49:50
draft: true
id: 1998
tags: 
  - cxx
  - cpp
  - coroutine
  - std
  - iso
title: C++20 Coroutine
type: post
---

前言
================================================
最近的新闻里 C++20 已经确认的内容里已经有了协程组件，之前都是粗略看过这个协程草案。最近抽时间更加系统性的看了下接入和实现细节。

VC ```/await``` 选项。

Yield
================================================

```dot
digraph yield_relation {
  charset="utf-8";
  bgcolor="transparent";
  overlap=ipsep;
  dpi="192";
  fontsize="16";
  fontname="Noto Sans, DejaVu Sans Mono, Noto Sans Mono CJK SC";
  node [shape = "box", fontsize="16", fontname="Noto Sans, DejaVu Sans Mono, Noto Sans Mono CJK SC"];
  edge [fontsize="16", fontname="Noto Sans, DejaVu Sans Mono, Noto Sans Mono CJK SC"];


  node_promise [label="Promise|get_return_object_on_allocation_failure|get_return_object|initial_suspend|final_suspend|unhandled_exception|return_void|yield_value", shape = "record"];
  node_handle [label="std::experimental::coroutine_handle<T>", shape = "record"];
  node_custom_generator [label="Custom Generator|handle", shape = "record"];
}
```

```cpp
#include <iostream>
#include <iomanip>
#include <vector>
#include <memory>

#include <experimental/coroutine>

struct test_rpc_generator {
    test_rpc_generator(const test_rpc_generator&) = delete;
    test_rpc_generator(test_rpc_generator&& other): coro(other.coro) {
        other.coro = nullptr;
    };
    ~test_rpc_generator() {
        if (coro) {
            coro.destroy();
        }
    }

    struct promise_type;
    using handle = std::experimental::coroutine_handle<promise_type>;

    struct promise_type {
        int* current_value;
        static auto get_return_object_on_allocation_failure() { 
            return test_rpc_generator{nullptr}; 
        }
        
        auto get_return_object() { 
            return test_rpc_generator{handle::from_promise(*this)}; 
        }
        
        auto initial_suspend() {
            current_value = nullptr;
            return std::experimental::suspend_never{}; 
        }
        
        auto final_suspend() { 
            return std::experimental::suspend_always{}; 
        }
        
        void unhandled_exception() { 
            std::terminate(); 
        }
        
        void return_void() {
        }
        
        auto yield_value(int* value) {
            current_value = value;
            return std::experimental::suspend_always{};
        }
    };


    int* value() const {
        if (coro) {
            return coro.promise().current_value;
        }

        return 0;
    }

    bool move_next(int rpc_result) {
        if (coro && coro.promise().current_value) {
            *coro.promise().current_value = rpc_result;
        }

        return coro ? (coro.resume(), !coro.done()) : false; 
    }

    bool await_ready() const {
        return !coro || coro.done();
    }

private:
    test_rpc_generator(handle h) : coro(h) {}
    handle coro;
};

test_rpc_generator f() {
    int rpc_res1, rpc_res2;
    co_yield &rpc_res1;
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< std::endl;

    co_yield &rpc_res2; 
    std::cout<< "resumed got rpc_res2: "<< rpc_res2<< std::endl;
}

int main(int argc, char * argv[]) {
#ifdef __cpp_coroutines
    std::cout<< "__cpp_coroutines: "<< __cpp_coroutines<< std::endl;
#endif

    //test_task::ptr_t tasks[3];

    //for (decltype(auto) task: tasks) {
    //    task = std::make_shared<test_task>();
    //}

    //while (run_tasks(tasks, tasks + 3));

    int rpc_fake_data = 1;
    auto g = f();
    while (g.move_next(++ rpc_fake_data)) {
        std::cout << g.value() << std::endl;
    }
    return 0;
}
```

Await
================================================

```cpp
#include <iostream>
#include <iomanip>
#include <vector>

#include <memory>

#include <experimental/coroutine>

struct test_rpc_generator {
    test_rpc_generator(const test_rpc_generator&) = delete;
    test_rpc_generator(test_rpc_generator&& other): coro(other.coro) {
        other.coro = nullptr;
    };
    ~test_rpc_generator() {
        if (coro) {
            coro.destroy();
        }
    }

    struct promise_type;
    using handle = std::experimental::coroutine_handle<promise_type>;

    struct promise_type {
        int* current_value;
        static auto get_return_object_on_allocation_failure() { 
            return test_rpc_generator{nullptr}; 
        }
        
        auto get_return_object() { 
            return test_rpc_generator{handle::from_promise(*this)}; 
        }
        
        auto initial_suspend() {
            current_value = nullptr;
            return std::experimental::suspend_never{}; 
        }
        
        auto final_suspend() { 
            return std::experimental::suspend_always{}; 
        }
        
        void unhandled_exception() { 
            std::terminate(); 
        }
        
        void return_void() {
        }
        
        auto yield_value(int* value) {
            current_value = value;
            return std::experimental::suspend_always{};
        }
    };


    int* value() const {
        if (coro) {
            return coro.promise().current_value;
        }

        return 0;
    }

    bool move_next(int rpc_result) {
        if (coro && coro.promise().current_value) {
            *coro.promise().current_value = rpc_result;
        }

        return coro ? (coro.resume(), !coro.done()) : false; 
    }

    bool await_ready() const {
        return !coro || coro.done();
    }

private:
    test_rpc_generator(handle h) : coro(h) {}
    handle coro;
};

test_rpc_generator f() {
    int rpc_res1, rpc_res2;
    co_yield &rpc_res1;
    // _alloca(rpc_res1);
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< "(@"<< &rpc_res1<< ")" << std::endl;

    co_yield &rpc_res2;
    // _alloca(rpc_res2);
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< "(@"<< &rpc_res1<< ")" << ", rpc_res2: "<< rpc_res2 <<"(@"<< &rpc_res2<< ")"<< std::endl;
}

struct test_task {
    using ptr_t = std::shared_ptr<test_task> ;

    test_task(int ms): status(0), max_status(ms) {}

    bool is_ready() const noexcept {
		return status >= max_status;
    }

    int status;
    int max_status;
};


struct test_task_future {
    struct promise_type;
    using ptr_t = std::shared_ptr<test_task>;
    using handle = std::experimental::coroutine_handle<promise_type>;

    struct awaiter_base {
        awaiter_base(ptr_t p): data(p) {};

        bool await_ready() const { 
            bool ret = !data || data->is_ready();
            if (ret) {
                std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " ready"<< std::endl;
            }

            return ret;
        }

        void await_resume() {
            if (data) {
                ++ data->status;
            }

            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " resume to "<< (data? data->status : -1)<< std::endl;
        }

        void await_suspend(test_rpc_generator::handle h) {
            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " suspend test_rpc_generator::handle from "<< (data? data->status : -1)<< 
                ", wait for "<< h.address()<< std::endl;
        }

        void await_suspend(handle h) {
            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " suspend test_task_future::handle from "<< (data? data->status : -1)<< 
                ", wait for "<< h.address()<< std::endl;
        }

        ptr_t data;
    };

    struct promise_type {
        static auto get_return_object_on_allocation_failure() { 
            return test_task_future{nullptr}; 
        }
        
        auto get_return_object() { 
            return test_task_future{handle::from_promise(*this)}; 
        }
        
        auto initial_suspend() {
            return std::experimental::suspend_never{}; 
        }
        
        auto final_suspend() { 
            return std::experimental::suspend_always{}; 
        }
        
        void unhandled_exception() { 
            std::terminate(); 
        }
        
        void return_void() {
        }

        auto return_value(int x) {
            task = std::make_shared<test_task>(x);
            return task;
        }

        ptr_t task;
    };


    ptr_t get_task() const noexcept {
        if (coro) {
            return coro.promise().task;
        }

        return nullptr;
    }
private:
    test_task_future(handle h): coro(h) {}

    handle coro;
};

//auto operator co_await(const test_task::ptr_t& pt) noexcept {
//    struct awaitable : test_task_future::awaiter_base {
//		using awaiter::awaiter;
//
//        void await_suspend(test_task_future::handle h) {
//            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " suspend from "<< (data? data->status : -1)<< 
//                ", wait for "<< h.address()<< std::endl;
//        }
//	};
//
//	return awaitable { pt };
//}

test_task_future h() {
    co_return 5;
}

test_task_future g() {
    std::cout<< "start to await h1 ..."<< std::endl;

    // co_await f();

    co_await h();

    std::cout<< "start to await h2 ..."<< std::endl;

    co_await h();

    std::cout<< "all resumed, abort to finish"<< std::endl;
}

//auto run_tasks(test_task::ptr_t* begin, test_task::ptr_t* end) {
//    bool ret = false;
//
//    for(; begin && end && begin < end; ++ begin) {
//        decltype(auto) task = *begin;
//        if (task && !task->is_ready()) {
//            ret = true;
//            co_await run_async(*task);
//        }
//    }
//
//    return ret;
//}

int main(int argc, char * argv[]) {
#ifdef __cpp_coroutines
    std::cout<< "__cpp_coroutines: "<< __cpp_coroutines<< std::endl;
#endif

    //test_task::ptr_t tasks[3];

    //for (decltype(auto) task: tasks) {
    //    task = std::make_shared<test_task>();
    //}

    //while (run_tasks(tasks, tasks + 3));

    // g();

    int rpc_fake_data = 1;
    auto g1 = f();
    auto g2 = f();
    void* detect_addr = malloc(4000);
    std::cout << "detect_addr:" << detect_addr << std::endl;
    free(detect_addr);

    for (bool is_continue = true; is_continue; is_continue = (!g1.await_ready() || !g2.await_ready())) {
        if (!g1.await_ready()) {
            g1.move_next(++ rpc_fake_data);
            std::cout << "g1 value:" << g1.value() << std::endl;
        }

        if (!g2.await_ready()) {
            g2.move_next(++ rpc_fake_data);
            std::cout << "g2 value:" << g2.value() << std::endl;
        }
    }
    return 0;
}
```

[1]: https://github.com/owt5008137/libcopp
[2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0973r0.pdf
[3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf
