---
author: owent
categories:
  - Article
  - Blablabla
date: 2026-01-11 01:15:45
draft: false
id: 2603
tags: 
  - protobuf
  - ABI
title: Protobuf又一坑 - C++标准和ABI兼容性
type: post
---

## 背景

前段时间例行更新我之前为我们游戏框架写的构建系统 [cmake-toolset][1] 的时候，又发现了 [protobuf][2] 的新ABI兼容性问题。

这已经不是第一次碰到 [protobuf][2] 的ABI兼容性问题了，这次也简单分析下并给出解决方案，希望能给大家碰到类似问题的同学做参考。

- 编译环境: Windows + Visual Studio 2026
- Abseil-Cpp version: 20250512.1
- Protobuf version: v31.1 (看起来目前最新的v33.1也有这问题)

# 错误分析

首先是链接是出现错误:

```text
[build] test_pb.pb.obj : error LNK2001: 无法解析的外部符号 "class google::protobuf::internal::GlobalEmptyStringConstexpr const google::protobuf::internal::fixed_address_empty_string" (?fixed_address_empty_string@internal@protobuf@google@@3VGlobalEmptyStringConstexpr@123@B) [D:\workspace\git\github\atframework\cmake-toolset\test\build_jobs_dir\cmake-toolset-test.vcxproj]
[build] D:\workspace\git\github\atframework\cmake-toolset\test\build_jobs_dir\bin\Debug\cmake-toolset-test.exe : fatal error LNK1120: 1 个无法解析的外部命令 [D:\workspace\git\github\atframework\cmake-toolset\test\build_jobs_dir\cmake-toolset-test.vcxproj]
```

我给 [opentelemetry-cpp][3] 社区也提了一个issue (https://github.com/open-telemetry/opentelemetry-cpp/issues/3799) ，问题是一样的。

让我们来看看相关代码:

首先是生成的 `.pb.cc` 里会有这样的代码:

```cpp
inline constexpr EntityRef::Impl_::Impl_(
    ::_pbi::ConstantInitialized) noexcept
      : id_keys_{},
        description_keys_{},
        schema_url_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        type_(
            &::google::protobuf::internal::fixed_address_empty_string,
            ::_pbi::ConstantInitialized()),
        _cached_size_{0} {}
```

但是protobuf的代码文件 **port.h** 里有如下定义:

```cpp
class alignas(8) GlobalEmptyStringConstexpr {
 public:
  const std::string& get() const { return value_; }
  // Nothing to init, or destroy.
  std::string* Init() const { return nullptr; }

  template <typename T = std::string, bool = (T(), true)>
  static constexpr std::true_type HasConstexprDefaultConstructor(int) {
    return {};
  }
  static constexpr std::false_type HasConstexprDefaultConstructor(char) {
    return {};
  }

 private:
  std::string value_;
};

using GlobalEmptyString = std::conditional_t<
    GlobalEmptyStringConstexpr::HasConstexprDefaultConstructor(0),
    const GlobalEmptyStringConstexpr, GlobalEmptyStringDynamicInit>;

PROTOBUF_EXPORT extern GlobalEmptyString fixed_address_empty_string;
```

对应protobuf的代码文件 **port.cc** 里有如下内容:

```bash
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GlobalEmptyString
        fixed_address_empty_string{};
```

阅读C++文档 <https://en.cppreference.com/w/cpp/string/basic_string/basic_string.html> 可知 `std::string` 的构造函数仅在C++20之后才支持 constexpr 构造。那么问题就显而易见了，如果protobuf使用 C++17编译，而 `.pb.cc` 使用C++20编译，那么两边的的 GlobalEmptyString 定义就会对不上，而导致符号缺失。

## 解决方法

初步想法的解决方法也很简单，就是如果protobuf使用某个STD版本编译，那么proto也使用哪个版本。
那么怎么知道 protobuf 构建使用的是哪个版本的STD呢？在所幸我的 [cmake-toolset][1] 是基于cmake的，兼容cmake的原生生态，而protobuf导出的包文件里包含了feature信息。

```cmake
set_target_properties(protobuf::libprotobuf PROPERTIES
  INTERFACE_COMPILE_FEATURES "cxx_std_17"
  INTERFACE_INCLUDE_DIRECTORIES "${_IMPORT_PREFIX}/include"
  INTERFACE_LINK_LIBRARIES "\$<LINK_ONLY:ZLIB::ZLIB>;absl::absl_check;absl::absl_log;absl::algorithm;absl::base;absl::bind_front;absl::bits;absl::btree;absl::cleanup;absl::cord;absl::core_headers;absl::debugging;absl::die_if_null;absl::dynamic_annotations;absl::flags;absl::flat_hash_map;absl::flat_hash_set;absl::function_ref;absl::hash;absl::if_constexpr;absl::layout;absl::log_initialize;absl::log_globals;absl::log_severity;absl::memory;absl::node_hash_map;absl::node_hash_set;absl::optional;absl::random_distributions;absl::random_random;absl::span;absl::status;absl::statusor;absl::strings;absl::synchronization;absl::time;absl::type_traits;absl::utility;absl::variant;\$<LINK_ONLY:utf8_range::utf8_validity>"
)
```

我们可以获取 `INTERFACE_COMPILE_FEATURES` 来找到当前使用C++17。所以我首先优化了我们的protobuf target的patch接口（因为我们的代码告警开得比较全，protobuf生成的代码经常会触发一些严格的告警，我们原来提供了patch接口来屏蔽这些告警 ）如下：

```cmake
function(project_build_tools_patch_protobuf_targets)
  # 如果之前找到了 cxx_std_NN 的 INTERFACE_COMPILE_FEATURES, 就把 ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD 设置成这个标准数字部分
  if(ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD)
    foreach(PROTO_TARGET ${ARGN})
      set_target_properties(${PROTO_TARGET} PROPERTIES CXX_STANDARD
                                                       ${ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD})
    endforeach()

    if(MSVC)
      set(__additional_cxx_standard "/std:c++${ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD}")
    else()
      set(__additional_cxx_standard "-std=c++${ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD}")
    endif()
  endif()
  foreach(PROTO_TARGET ${ARGN})
    set(PROTO_TARGET_OPTIONS_CHANGED FALSE)
    get_target_property(PROTO_TARGET_OPTIONS ${PROTO_TARGET} COMPILE_OPTIONS)
    if(PROTO_TARGET_OPTIONS)
      set(__need_cxx_standard TRUE)
      if(NOT ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD
         OR PROTO_TARGET_OPTIONS MATCHES
            "(/std:|-std=)(c|gnu)\\+\\+${ATFRAMEWORK_CMAKE_TOOLSET_THIRD_PARTY_PROTOBUF_CXX_STANDARD}")
        set(__need_cxx_standard FALSE)
      else()
        if(MSVC)
          string(REGEX REPLACE "/std:c\\+\\+[0-9a-zA-Z_]+" "" PROTO_TARGET_OPTIONS "${PROTO_TARGET_OPTIONS}")
        endif()
        string(REGEX REPLACE "-std=(c|gnu)\\+\\+[0-9a-zA-Z_]+" "" PROTO_TARGET_OPTIONS "${PROTO_TARGET_OPTIONS}")
        set(__need_cxx_standard TRUE)
      endif()

      # 我们原来有一些根据编译环境生产的Patch编译选项，放在 PROJECT_BUILD_TOOLS_PATCH_PROTOBUF_SOURCES_OPTIONS ，这里是做融合
      foreach(TEST_OPTION ${PROJECT_BUILD_TOOLS_PATCH_PROTOBUF_SOURCES_OPTIONS})
        if(NOT "${TEST_OPTION}" IN_LIST PROTO_TARGET_OPTIONS)
          list(APPEND PROTO_TARGET_OPTIONS "${TEST_OPTION}")
          set(PROTO_TARGET_OPTIONS_CHANGED TRUE)
        endif()
      endforeach()
      if(__need_cxx_standard)
        list(APPEND PROTO_TARGET_OPTIONS "${__additional_cxx_standard}")
        set(PROTO_TARGET_OPTIONS_CHANGED TRUE)
      endif()
    else()
      set(PROTO_TARGET_OPTIONS ${PROJECT_BUILD_TOOLS_PATCH_PROTOBUF_SOURCES_OPTIONS})
      if(__additional_cxx_standard)
        list(APPEND PROTO_TARGET_OPTIONS "${__additional_cxx_standard}")
      endif()
      set(PROTO_TARGET_OPTIONS_CHANGED TRUE)
    endif()
    if(PROTO_TARGET_OPTIONS_CHANGED)
      set_target_properties(${PROTO_TARGET} PROPERTIES COMPILE_OPTIONS "${PROTO_TARGET_OPTIONS}")
    endif()
  endforeach()
endfunction()
```

但是整个这么替换之后，出现了两个新问题:

### 新问题一: cxx_std_NN 不一定完全准确

实际上上游使用了C++ 17

```text
C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.44.35207\include\string_view(12): warning STL4038: The contents of <string_view> are available only with C++17 or later. [D:\a\opentelemetry-cpp\opentelemetry-cpp\build\opentelemetry_proto.vcxproj]
  (compiling source file '../../../../generated/third_party/opentelemetry-proto/opentelemetry/proto/common/v1/common.pb.cc')
      C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Tools\MSVC\14.44.35207\include\vector(29,1):
      see declaration of 'std'
  
D:\a\opentelemetry-cpp\opentelemetry-cpp\tools\vcpkg\installed\x64-windows\include\absl\strings\string_view.h(53,26): error C2061: syntax error: identifier 'string_view' [D:\a\opentelemetry-cpp\opentelemetry-cpp\build\opentelemetry_proto.vcxproj]
  (compiling source file '../../../../generated/third_party/opentelemetry-proto/opentelemetry/proto/common/v1/common.pb.cc')
```

但是protobuf的package是 cxx_std_14:

```cmake
get_target_property(protobuf_lib_compile_features protobuf::libprotobuf INTERFACE_COMPILE_FEATURES)
if(protobuf_lib_compile_features MATCHES "(^|\\s)cxx_std_([0-9]+)(|$\\s)")
  message(
    STATUS
      "protobuf::libprotobuf detected compile features cxx_std_${CMAKE_MATCH_2}."
  )
endif()
```

这段代码的输出是 `-- protobuf::libprotobuf detected compile features cxx_std_14.` 。

那么我们的解决方法就是不要完全依赖于 cxx_std_NN , 而是以C++20作为分界线，如果跨越了就设置成保持ABI兼容的最大值。

```cmake
if(DEFINED CMAKE_CXX_STANDARD AND protobuf_lib_compile_features MATCHES
                                  "(^|\\s)cxx_std_([0-9]+)(|$\\s)")
  # Wether the protobuf library using C++20 or higher may have different
  # ABI. We need to make sure our proto targets are using the same C++
  # standard.
  if(${CMAKE_MATCH_2} LESS 20 AND CMAKE_CXX_STANDARD GREATER_EQUAL 20)
    # Some versions of protobuf will set cxx_std_14, but qctually require
    # c++17
    set(protobuf_lib_compile_features_cxx_std 17)
  elseif(${CMAKE_MATCH_2} GREATER_EQUAL 20 AND CMAKE_CXX_STANDARD LESS 20)
    set(protobuf_lib_compile_features_cxx_std ${CMAKE_MATCH_2})
  endif()
  message(
    STATUS
      "protobuf::libprotobuf detected compile features cxx_std_${CMAKE_MATCH_2}."
  )
endif()
```

### 新问题二: 上游abseil-cpp如果使用C++20编译，会有组件设置不匹配

在Linux+GCC上，会有如下编译错误:

```text
[  2%] Building CXX object CMakeFiles/opentelemetry_proto.dir/generated/third_party/opentelemetry-proto/opentelemetry/proto/resource/v1/resource.pb.cc.o
In file included from /usr/local/include/absl/numeric/int128.h:41,
                 from /usr/local/include/absl/strings/internal/str_format/arg.h:35,
                 from /usr/local/include/absl/strings/str_format.h:83,
                 from /usr/local/include/absl/crc/crc32c.h:32,
                 from /usr/local/include/absl/crc/internal/crc_cord_state.h:23,
                 from /usr/local/include/absl/strings/cord.h:80,
                 from /usr/local/include/google/protobuf/io/coded_stream.h:111,
                 from /home/runner/build/generated/third_party/opentelemetry-proto/opentelemetry/proto/resource/v1/resource.pb.h:20,
                 from /home/runner/build/generated/third_party/opentelemetry-proto/opentelemetry/proto/resource/v1/resource.pb.cc:6:
/usr/local/include/absl/types/compare.h:60:12: error: ‘partial_ordering’ has not been declared in ‘std’
   60 | using std::partial_ordering;
      |            ^~~~~~~~~~~~~~~~
/usr/local/include/absl/types/compare.h:61:12: error: ‘strong_ordering’ has not been declared in ‘std’
   61 | using std::strong_ordering;
      |            ^~~~~~~~~~~~~~~
/usr/local/include/absl/types/compare.h:62:12: error: ‘weak_ordering’ has not been declared in ‘std’
   62 | using std::weak_ordering;
      |            ^~~~~~~~~~~~~
/usr/local/include/absl/types/compare.h:455:56: error: ‘weak_ordering’ in namespace ‘absl’ does not name a type
  455 | constexpr bool compare_result_as_less_than(const absl::weak_ordering r) {
      |                                                        ^~~~~~~~~~~~~
/usr/local/include/absl/types/compare.h:470:17: error: ‘weak_ordering’ in namespace ‘absl’ does not name a type
  470 | constexpr absl::weak_ordering compare_result_as_ordering(const Int c) {
```

其中 [Three-way comparison](https://en.cppreference.com/w/cpp/language/operator_comparison.html#Three-way_comparison) 是C++20的内容，详见: <https://en.cppreference.com/w/cpp/language/operator_comparison.html#Three-way_comparison> 。所以在Linux上，我们还不能降低 .pb.cc 的STD版本，不然这里又会对不上。

实际上，现在的protobuf版本里指明了 `target_compile_features("${target}" PUBLIC cxx_std_17)` 。如果我们使用了 `-DCMAKE_CXX_STANDARD=20` ，实际会使用C++20，但是导出的package里还是 `cxx_std_17` 。这是导致这里对不上的原因。

所以更稳妥的方法可能是使用下面代码分别测试一下 `-std=c++17` 和 `-std=c++20` 。

```cpp
#include <iostream>
#include <google/protobuf/message.h>
int main () {
  std::cout<< ::google::protobuf::internal::fixed_address_empty_string.get()<< std::endl;
  return 0;
}
```

当然实际情况还得区分protobuf版本，会更复杂一些。

## 官方的临时解决方案

当前时间点，最新 [protobuf][2] 主干分支已经把代码改成了下面这样，在MSVC下强制走非 constexpr 的版本。这样应该也能临时解决上面提到的这个问题。

```cpp
// Take advantage of C++20 constexpr support in std::string.
class alignas(8) GlobalEmptyStringConstexpr {
 public:
  const std::string& get() const { return value_; }
  // Nothing to init, or destroy.
  std::string* Init() const { return nullptr; }

  // Disable the optimization for MSVC and Xtensa.
  // There are some builds where the default constructed string can't be used as
  // `constinit` even though the constructor is `constexpr` and can be used
  // during constant evaluation.
#if !defined(_MSC_VER) && !defined(__XTENSA__)
  // Compilation fails on Xtensa: b/467129751
  template <typename T = std::string, bool = (T(), true)>
  static constexpr std::true_type HasConstexprDefaultConstructor(int) {
    return {};
  }
#endif
  static constexpr std::false_type HasConstexprDefaultConstructor(char) {
    return {};
  }

 private:
  std::string value_;
};
```

## 最后

Google下 [protobuf][2] 生态的东西坑蛮多的，如果有小伙伴对我们之前踩的其他坑感兴趣也可以直接Blog里搜索protobuf。

欢迎小伙伴们交流拍砖。

[1]: https://github.com/atframework/cmake-toolset
[2]: https://github.com/protocolbuffers/protobuf
[3]: https://github.com/open-telemetry/opentelemetry-cpp
