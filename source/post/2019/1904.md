---
author: owent
categories:
  - Article
  - Blablabla
date: 2019-12-11 22:49:50
draft: true
id: 1904
tags: 
  - cxx
  - cpp
  - coroutine
  - std
  - iso
title: C++20 Coroutine
type: post
---

前言
================================================
最近的新闻里 C++20 已经确认的内容里已经有了协程组件，之前都是粗略看过这个协程草案。最近抽时间更加系统性的看了下接入和实现细节。

我的测试代码都是在MSVC下开启 ```/await``` 选项后测试的，还没有测试clang下的表现，但是原理应该类似吧。等正式版本出来了可以再看一下是否有差异。

C++20 的协程基本原理
================================================
C++20 整个协程体系是 **"无栈协程"** 的思路，整个功能是需要结合编译器功能和STL来配合实现的。主要就是三个关键字（```co_yield``` 、  ```co_await``` 或 ```co_return```）和围绕这三个关键字的接入。无栈协程对API的设计是有要求的，C++20 Coroutine也不例外， 编译器在检测到内部有使用 这三个关键字时会对函数的流程做patch，然后它的返回值类型必须符合你所使用的关键字的规范。这三个关键字的规范要求不太一样，下面会列举。

我原本以为的会放在协程的 **awaiter** 或者 **handle** 对象闭包里，然后由编译器分析和对闭包内的各级对象进行扩充的引用（类似Rust的那种实现）。但是在测试的MSVC的协程流程的过程中发现，实际上还是另外堆上分配空间来保存协程函数的栈上数据，并用这种方式实现Zero-Copy的。这和之前猜想的不太一样。所以，C++20 的协程也不能完全说是 **"无栈"** ，只是在协程函数中需要能够评估出来它需要多少栈空间存数据，不像有栈协程那样会浪费比较大的地址空间且不利于内存页复用。

同时受限于这种设计，在C++20 的协程函数里，动态栈分配是不受支持的。如果你使用了动态栈分配的函数 (VC 是 ```_alloca``` 、 gcc/clang 是 ```alloc``` ) ，直接编译就不通过了。

> 不过我觉得类似GCC动态栈的那种方案可以让它支持动态栈空间，就是在栈溢出的signal里再mmap一段地址进去，按需增大栈空间。但是这玩意性能被诟病，信号和缺页中断都不稳定且栈空间地址分散不利于CPU Cache，估计最后也不会被采纳吧。

我目前看的提案以 [N4736][2] 为准。一旦一个函数被断定为协程函数，那么它会被扩充为如下形式:

```cpp
COROUTINE_OBJECT func(args...) {
    P p(promise_constructor_arguments);
    // 这个P是自己定义的 using P = COROUTINE_OBJECT::promise_type;
    // promise_constructor_arguments 是空或者函数的参数的左值传入 args...

    COROUTINE_OBJECT r = p.get_return_object();
    if (nullptr == r) {
        r = p.get_return_object_on_allocation_failure(); // noexcept
    }

    co_await p.initial_suspend();   // 初始化接口

    try {
        // 原函数体 ...
        p.return_void() or p.return_value(RET) // 取决于函数体里有没有 co_return RET
    } catch(...) {
        p.unhandled_exception();    // 未捕获的异常接口
    }
final_suspend:
    co_await p.final_suspend();     // final suspend point

    return r;
}
```

```co_await``` 关键字先简单理解为判定是否需要切出，它的功能和其他的部分连带比较多，没法单独出现，所以放在最后。
而协程函数一切的核心都在于上面的 ```COROUTINE_OBJECT``` 类型。里面有一些规范， ```co_yield``` 和 ```co_return``` 涉及 ```COROUTINE_OBJECT``` 里的 ```COROUTINE_OBJECT::promise_type``` 类型。必须实现某些公共接口和函数功能接口。而返回到外层的 ```COROUTINE_OBJECT``` 对象里也需要保存协程的handle(目前是 ```std::experimental::coroutine_handle<PROMISE_TYPE>``` )，以用于后续控制协程的上下文切换使用。 同样， 下面的例子因为必须写一个协程入口对象，所以有一部分比较烦杂的必须接入的代码。

co_yield
================================================

Paper里最先提到的是 ```co_await``` ，但是我觉得从 ```co_yield``` 开始入手比较易于理解。

```co_yield``` 要求实现 ```COROUTINE_OBJECT::promise_type::yield_value(参数)``` 。比较贴近于单独一次异步调用的实现。

```co_yield VALUE``` 简单的描述是相当于 ```co_await p.yield_value(VALUE)``` 。 然后awaiter是一个临时变量，在这条语句结束后析构。

```dot
digraph yield_relation {
  charset="utf-8";
  bgcolor="transparent";
  overlap=ipsep;
  dpi="192";
  fontsize="16";
  fontname="Noto Sans, DejaVu Sans Mono, Noto Sans Mono CJK SC";
  node [shape = "box", fontsize="16", fontname="Noto Sans, DejaVu Sans Mono, Noto Sans Mono CJK SC"];
  edge [fontsize="16", fontname="Noto Sans, DejaVu Sans Mono, Noto Sans Mono CJK SC"];


  node_promise [label="Promise|get_return_object_on_allocation_failure|get_return_object|initial_suspend|final_suspend|unhandled_exception|return_void|yield_value", shape = "record"];
  node_handle [label="std::experimental::coroutine_handle<T>", shape = "record"];
  node_custom_generator [label="Custom Generator|handle", shape = "record"];
}
```

```cpp
#include <iostream>
#include <iomanip>
#include <vector>

#include <memory>

#include <experimental/coroutine>

struct test_rpc_generator {
    test_rpc_generator(const test_rpc_generator&) = delete;
    test_rpc_generator(test_rpc_generator&& other): coro(other.coro) {
        other.coro = nullptr;
    };
    ~test_rpc_generator() {
        if (coro) {
            coro.destroy();
        }
    }

    struct promise_type;
    using handle = std::experimental::coroutine_handle<promise_type>;

    struct promise_type {
        int* current_value;
        static auto get_return_object_on_allocation_failure() {
            return test_rpc_generator{nullptr};
        }

        auto get_return_object() {
            return test_rpc_generator{handle::from_promise(*this)};
        }

        auto initial_suspend() {
            current_value = nullptr;
            return std::experimental::suspend_never{};
        }

        auto final_suspend() {
            return std::experimental::suspend_always{};
        }

        void unhandled_exception() {
            std::terminate();
        }

        void return_void() {
        }

        auto yield_value(int* value) {
            current_value = value;
            return std::experimental::suspend_always{};
        }
    };


    int* value() const {
        if (coro) {
            return coro.promise().current_value;
        }

        return 0;
    }

    bool move_next(int rpc_result) {
        if (coro && coro.promise().current_value) {
            *coro.promise().current_value = rpc_result;
        }

        return coro ? (coro.resume(), !coro.done()) : false; 
    }

    bool await_ready() const {
        return !coro || coro.done();
    }

private:
    test_rpc_generator(handle h) : coro(h) {}
    handle coro;
};

test_rpc_generator f() {
    int rpc_res1, rpc_res2;
    co_yield &rpc_res1;
    // _alloca(rpc_res1);
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< "(@"<< &rpc_res1<< ")" << std::endl;

    co_yield &rpc_res2;
    // _alloca(rpc_res2);
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< "(@"<< &rpc_res1<< ")" << ", rpc_res2: "<< rpc_res2 <<"(@"<< &rpc_res2<< ")"<< std::endl;
}

int main(int argc, char * argv[]) {
#ifdef __cpp_coroutines
    std::cout<< "__cpp_coroutines: "<< __cpp_coroutines<< std::endl;
#endif

    int rpc_fake_data = 1;
    auto g1 = f();
    auto g2 = f();
    void* detect_addr = malloc(4000);
    std::cout << "detect_addr:" << detect_addr << std::endl;
    free(detect_addr);

    for (bool is_continue = true; is_continue; is_continue = (!g1.await_ready() || !g2.await_ready())) {
        if (!g1.await_ready()) {
            g1.move_next(++ rpc_fake_data);
            std::cout << "g1 value:" << g1.value() << std::endl;
        }

        if (!g2.await_ready()) {
            g2.move_next(++ rpc_fake_data);
            std::cout << "g2 value:" << g2.value() << std::endl;
        }
    }
    return 0;
}
```

我这里一次示例输出是:

```
__cpp_coroutines: 201703
detect_addr:00881BD0
resumed got rpc_res1: 2(@0087F96C)
g1 value:0087F980
resumed got rpc_res1: 3(@00881B1C)
g2 value:00881B30
resumed got rpc_res1: 2(@0087F96C), rpc_res2: 4(@0087F980)
g1 value:0087F980
resumed got rpc_res1: 3(@00881B1C), rpc_res2: 5(@00881B30)
g2 value:00881B30
```

co_await
================================================

```cpp
#include <iostream>
#include <iomanip>
#include <vector>

#include <memory>

#include <experimental/coroutine>

struct test_rpc_generator {
    test_rpc_generator(const test_rpc_generator&) = delete;
    test_rpc_generator(test_rpc_generator&& other): coro(other.coro) {
        other.coro = nullptr;
    };
    ~test_rpc_generator() {
        if (coro) {
            coro.destroy();
        }
    }

    struct promise_type;
    using handle = std::experimental::coroutine_handle<promise_type>;

    struct promise_type {
        int* current_value;
        static auto get_return_object_on_allocation_failure() {
            return test_rpc_generator{nullptr};
        }

        auto get_return_object() {
            return test_rpc_generator{handle::from_promise(*this)};
        }

        auto initial_suspend() {
            current_value = nullptr;
            return std::experimental::suspend_never{};
        }

        auto final_suspend() {
            return std::experimental::suspend_always{};
        }

        void unhandled_exception() {
            std::terminate();
        }

        void return_void() {
        }

        auto yield_value(int* value) {
            current_value = value;
            return std::experimental::suspend_always{};
        }
    };


    int* value() const {
        if (coro) {
            return coro.promise().current_value;
        }

        return 0;
    }

    bool move_next(int rpc_result) {
        if (coro && coro.promise().current_value) {
            *coro.promise().current_value = rpc_result;
        }

        return coro ? (coro.resume(), !coro.done()) : false; 
    }

    bool await_ready() const {
        return !coro || coro.done();
    }

private:
    test_rpc_generator(handle h) : coro(h) {}
    handle coro;
};

test_rpc_generator f() {
    int rpc_res1, rpc_res2;
    co_yield &rpc_res1;
    // _alloca(rpc_res1);
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< "(@"<< &rpc_res1<< ")" << std::endl;

    co_yield &rpc_res2;
    // _alloca(rpc_res2);
    std::cout<< "resumed got rpc_res1: "<< rpc_res1<< "(@"<< &rpc_res1<< ")" << ", rpc_res2: "<< rpc_res2 <<"(@"<< &rpc_res2<< ")"<< std::endl;
}

struct test_task {
    using ptr_t = std::shared_ptr<test_task> ;

    test_task(int ms): status(0), max_status(ms) {}

    bool is_ready() const noexcept {
		return status >= max_status;
    }

    int status;
    int max_status;
};


struct test_task_future {
    struct promise_type;
    using ptr_t = std::shared_ptr<test_task>;
    using handle = std::experimental::coroutine_handle<promise_type>;

    struct awaiter_base {
        awaiter_base(ptr_t p): data(p) {};

        bool await_ready() const { 
            bool ret = !data || data->is_ready();
            if (ret) {
                std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " ready"<< std::endl;
            }

            return ret;
        }

        void await_resume() {
            if (data) {
                ++ data->status;
            }

            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " resume to "<< (data? data->status : -1)<< std::endl;
        }

        void await_suspend(test_rpc_generator::handle h) {
            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " suspend test_rpc_generator::handle from "<< (data? data->status : -1)<< 
                ", wait for "<< h.address()<< std::endl;
        }

        void await_suspend(handle h) {
            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " suspend test_task_future::handle from "<< (data? data->status : -1)<< 
                ", wait for "<< h.address()<< std::endl;
        }

        ptr_t data;
    };

    struct promise_type {
        static auto get_return_object_on_allocation_failure() { 
            return test_task_future{nullptr}; 
        }
        
        auto get_return_object() { 
            return test_task_future{handle::from_promise(*this)}; 
        }
        
        auto initial_suspend() {
            return std::experimental::suspend_never{}; 
        }
        
        auto final_suspend() { 
            return std::experimental::suspend_always{}; 
        }
        
        void unhandled_exception() { 
            std::terminate(); 
        }
        
        void return_void() {
        }

        auto return_value(int x) {
            task = std::make_shared<test_task>(x);
            return task;
        }

        ptr_t task;
    };


    ptr_t get_task() const noexcept {
        if (coro) {
            return coro.promise().task;
        }

        return nullptr;
    }
private:
    test_task_future(handle h): coro(h) {}

    handle coro;
};

//auto operator co_await(const test_task::ptr_t& pt) noexcept {
//    struct awaitable : test_task_future::awaiter_base {
//		using awaiter::awaiter;
//
//        void await_suspend(test_task_future::handle h) {
//            std::cout<< std::setw(4)<< __LINE__<< ": task "<< data.get()<< " suspend from "<< (data? data->status : -1)<< 
//                ", wait for "<< h.address()<< std::endl;
//        }
//	};
//
//	return awaitable { pt };
//}

test_task_future h() {
    co_return 5;
}

test_task_future g() {
    std::cout<< "start to await h1 ..."<< std::endl;

    // co_await f();

    co_await h();

    std::cout<< "start to await h2 ..."<< std::endl;

    co_await h();

    std::cout<< "all resumed, abort to finish"<< std::endl;
}

//auto run_tasks(test_task::ptr_t* begin, test_task::ptr_t* end) {
//    bool ret = false;
//
//    for(; begin && end && begin < end; ++ begin) {
//        decltype(auto) task = *begin;
//        if (task && !task->is_ready()) {
//            ret = true;
//            co_await run_async(*task);
//        }
//    }
//
//    return ret;
//}

int main(int argc, char * argv[]) {
#ifdef __cpp_coroutines
    std::cout<< "__cpp_coroutines: "<< __cpp_coroutines<< std::endl;
#endif

    //test_task::ptr_t tasks[3];

    //for (decltype(auto) task: tasks) {
    //    task = std::make_shared<test_task>();
    //}

    //while (run_tasks(tasks, tasks + 3));

    // g();

    int rpc_fake_data = 1;
    auto g1 = f();
    auto g2 = f();
    void* detect_addr = malloc(4000);
    std::cout << "detect_addr:" << detect_addr << std::endl;
    free(detect_addr);

    for (bool is_continue = true; is_continue; is_continue = (!g1.await_ready() || !g2.await_ready())) {
        if (!g1.await_ready()) {
            g1.move_next(++ rpc_fake_data);
            std::cout << "g1 value:" << g1.value() << std::endl;
        }

        if (!g2.await_ready()) {
            g2.move_next(++ rpc_fake_data);
            std::cout << "g2 value:" << g2.value() << std::endl;
        }
    }
    return 0;
}
```

总结
================================================
统一的任务管理

[1]: https://github.com/owt5008137/libcopp
[2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0973r0.pdf
[3]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4736.pdf
