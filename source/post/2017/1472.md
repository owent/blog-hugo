```
---
author: owent
categories:
  - Article
  - Blablabla
date: 2017-11-10 13:30:00
draft: false
id: 1472
tags: []
title: ECDH椭圆双曲线密钥交换，2倍密钥长度，10倍性能
type: post
---
```

前面有几篇blog就提到我有计划支持使用ECC的DH密钥交换。近期也是抽空把以前的DH密钥交换跨平台适配从[atgateway][2]抽离出来，而后接入了ECDH流程。

## 背景
对[DH][5]和[ECDH][3]算法的具体原理这里不做具体介绍了，可以点击链接看。[DH][5]和[ECDH][3]的主要的作用就是在通信双方发送一些公有参数，而后通过一系列计算双方都能够得到一个一致的结果。而这个运算的逆运算复杂度过高，在有限时间内不可解（至少量子计算机问世以前不可解），以保证密钥安全性。除了维基百科外，我还看到篇文章图画的很好看的：http://andrea.corbellini.name/2015/05/30/elliptic-curve-cryptography-ecdh-and-ecdsa/

实际应用中，有些加密算法的密钥碰撞计算难度反而比破解[DH][5]和[ECDH][3]要容易（比如[atgateway][2]支持的[XXTEA][6]算法，这个算法很简单所以也非常高效）。所以有些工程实践中会每隔一段时间再走一次密钥交换流程来更换密钥。

## ECDH和DH

其实使用ECC做密钥交换，有时候你可能也会看到[ECDHE][3]这个名词，这个多出来的E的意思是指每次公钥都随机生成。因为像HTTPS里那种是可以从证书文件里取静态公钥的。我接入的其实也是每次都随机生成公钥。

### 适配和接入
我这里选择了按[RFC 4492][4]进行接入，因为我主要适配的两个库（[openssl][8]和[mbedtls][9]）共同支持的似乎只有[RFC 4492][4]。接入的过程中主要有三个问题。

第一个是[openssl][8]的1.0.1版本支持的算法较少，而高版本比较多一些，而且[openssl][8]本身是可以裁剪算法的。这个用宏来判定就行了，比较easy。

第二个是[openssl][8]和[mbedtls][9]都有自己内部的ID和名称，并且不一样，传参数都是用内部ID的，然后输出再做转换。解决方法就是手夯了一个映射表，和之前搞[crypto_cipher][10]得方法一样。

第三就是[openssl][8]的1.0.2和1.1.0的结构大不一样了，1.1.0版本的接口也更加严谨。这个比较麻烦，找了好久才找到1.1.0的这两部分代码实现。现在的做法是按1.1.0的方法封装了一些接口给1.0.1/1.0.2使用。比如这种:
```cpp
/**
 * @see crypto/dh/dh_lib.c in openssl 1.1.x
 */
static inline void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key) {
    if (pub_key != NULL) *pub_key = dh->pub_key;
    if (priv_key != NULL) *priv_key = dh->priv_key;
}
```

比较好的消息是[DH][5]和[ECDH][3]的流程基本一致，只是传输内容不同。但是[openssl][8]不像[mbedtls][9]，没有良好的接口封装，里面密钥交换的细节实现得到[openssl][8]的源码里去找。并且流程比较长，而且[openssl][8]的实现不太好，有很多冗余的拷贝操作。实际上我接入的时候是对它的代码流程有些许优化话，主要还是减少不必要的拷贝。[openssl][8]1.0.2的[ECDH][3]和[ECDSA][7]流程代码在ssl/s3_srvr.c和ssl/s3_clnt.c里，而1.1.0版本的相关流程代码在ssl/statem/statem_clnt.c和ssl/statem/statem_srvr.c里。版本适配代码大多在ssl/ssl_locl.h和ssl/t1_lib.c里。唉openssl的文档和代码看得真是蛋疼。

另外我只接入了密钥交换的流程，像它们其实有更高级的SSL/TLS接口，还包含验证流程、加解密流程、握手的cookie等等。我希望提供的是一个个单独可拆开用的组件，所以这里只接入了密钥交换。像加解密就封装到了[crypto_cipher][10]里。而像[atgateway][2]有自己的验证流程，并不像标准TLS/SSL那样走Hash。

### 交互流程差异

步骤                       | DH                                                       | ECDH
--------------------------|----------------------------------------------------------|----------------------------------------
初始化                     | 加载DH参数（主要是一个大素数P和系数G），由DH参数决定密钥长度      | 加载双曲线（[RFC 4492][4]），由双曲线决定密钥长度
服务器下发系数              | 下发DH算法的P（大素数）、G、GY(G^Y mod P)，保留私有数据Y        | 下发双曲线算法group和公钥点Q，保留私钥点d
服务器下发内容              | 2字节P长度，P,  2字节G长度，G,2字节GY长度，GY                  | 1字节类型(3)，2字节双曲线ID，1字节Q长度,Q
客户端读取系数              | 读入P、G,记录GY为远端公钥                                    | 读入双曲线算法group，记录Q为远端公钥
客户端创建公钥              | 随机出X，计算并上传GX(G^X mod P)，保留私有数据X                | 生成和上传公钥点Qp，保留私钥点z
客户端上传内容              | 2字节GX长度，GX                                            | 1字节Qp长度,Qp
客户端计算密钥              | 根据P、G、GY、X计算出密钥                                    | 根据group、Q、z计算出密钥
服务器计算密钥              | 根据P、G、GX、Y计算出密钥                                    | 根据group、Qp、d计算出密钥

## 关于单元测试和valgrind报告

抽离出来以后就比较方便加单元测试了。单元测试的时候发现openssl底层会分配一些全局数据，导致valgrind报still reachable。但是实测了多次不同次数的加解密后的报告的块数和总大小都一样。所以这个就可以忽略了。

然后就是报告的结果，我直接从CI里复制出来了一部分。Windows和Linux里的结果一致：

```
[ RUN      ] crypto_dh.dh
[ RUNNING  ] Test DH algorithm 32 times, key len 128 bits. 
[       OK ] crypto_dh.dh (228.725 ms)
[ RUN      ] crypto_dh.ecdh
[ RUNNING  ] Test ECDH algorithm 16 times for 8 curves done. 
[ RUNNING  ]   Fastest => ecdh:secp224r1 cost 0.60075ms(avg.) key len 224 bits. 
[ RUNNING  ]   Slowest => ecdh:secp384r1 cost 3.86687ms(avg.) key len 384 bits. 
[       OK ] crypto_dh.ecdh (221.049 ms)
```

这就是标题里说的**2倍密钥长度，10倍性能**的来源。可以看到，耗时最短的双曲线，密钥长度是224，平均每次耗时是0.6ms(client+server)。而DH用的是1024bits的DHParameter，密钥长度128，平均耗时是228.725/32=7.14ms 。而最慢的双曲线性能也是两倍多，而平均值是221.049/16/18=1.73ms，性能也是4倍多。

## API

现在涉及的接口非常简单，和[mbedtls][9]的流程很像。比如下面DH算法的（截取自单元测试）

```cpp
// 客户端共享配置
util::crypto::dh cli_dh;

// 服务器共享配置(保存DH系数等)
util::crypto::dh svr_dh;

// 服务器 - init: 读取DHParam的PEM文件
{
    util::crypto::dh::shared_context::ptr_t svr_shctx = util::crypto::dh::shared_context::create();

    std::string dir;
    CASE_EXPECT_TRUE(util::file_system::dirname(__FILE__, 0, dir, 2));
    dir += util::file_system::DIRECTORY_SEPARATOR;
    dir += "resource";
    dir += util::file_system::DIRECTORY_SEPARATOR;
    dir += "test-dhparam.pem";
    // 前面只是找到PEM文件路径
    CASE_EXPECT_EQ(0, svr_shctx->init(dir.c_str()));
    CASE_EXPECT_EQ(0, svr_dh.init(svr_shctx));
}

// 客户端 - init: 设置成DH模式
{
    util::crypto::dh::shared_context::ptr_t cli_shctx = util::crypto::dh::shared_context::create();
    CASE_EXPECT_EQ(0, cli_shctx->init(util::crypto::dh::method_t::EN_CDT_DH));
    CASE_EXPECT_EQ(0, cli_dh.init(cli_shctx));
}

std::vector<unsigned char> switch_params; // 服务器下发的数据
std::vector<unsigned char> switch_public; // 客户端上传的数据
std::vector<unsigned char> cli_secret; // 保存客户端计算的密钥
std::vector<unsigned char> svr_secret; // 保存服务器计算的密钥

// step 1 - 服务器: make private key and public key
CASE_EXPECT_EQ(0, svr_dh.make_params(switch_params));

// step 2 - 客户端: read dhparam and public key of 服务器
CASE_EXPECT_EQ(0, cli_dh.read_params(switch_params.data(), switch_params.size()));

// step 3 - 客户端: make public key
CASE_EXPECT_EQ(0, cli_dh.make_public(switch_public));

// step 4 - 客户端: calculate secret
CASE_EXPECT_EQ(0, cli_dh.calc_secret(cli_secret));

// step 5 - 服务器: read public key of 客户端
CASE_EXPECT_EQ(0, svr_dh.read_public(switch_public.data(), switch_public.size()));

// step 6 - 服务器: calculate secret
CASE_EXPECT_EQ(0, svr_dh.calc_secret(svr_secret));

// DH process done
CASE_EXPECT_EQ(cli_secret.size(), svr_secret.size());
if (cli_secret.size() == svr_secret.size()) {
    CASE_EXPECT_EQ(0, memcmp(cli_secret.data(), svr_secret.data(), svr_secret.size()));
}
```

还有ECDH算法的（截取自单元测试）

```cpp
// 枚举所有的加密算法
const std::vector<std::string> &all_curves = util::crypto::dh::get_all_curve_names();

for (size_t curve_idx = 0; curve_idx < all_curves.size(); ++curve_idx) {

    // 客户端共享配置
    util::crypto::dh cli_dh;

    // 服务器共享配置(保存椭圆算法ID等)
    util::crypto::dh svr_dh;

    // 服务器 - init: 读取指定的椭圆曲线
    {
        util::crypto::dh::shared_context::ptr_t svr_shctx = util::crypto::dh::shared_context::create();
        CASE_EXPECT_EQ(0, svr_shctx->init(all_curves[curve_idx].c_str()));
        CASE_EXPECT_EQ(0, svr_dh.init(svr_shctx));
    }

    // 客户端 - init: 设置为ECDH模式
    {
        util::crypto::dh::shared_context::ptr_t cli_shctx = util::crypto::dh::shared_context::create();
        CASE_EXPECT_EQ(0, cli_shctx->init(util::crypto::dh::method_t::EN_CDT_ECDH));
        CASE_EXPECT_EQ(0, cli_dh.init(cli_shctx));
    }

    std::vector<unsigned char> switch_params;  // 服务器下发的数据
    std::vector<unsigned char> switch_public;  // 客户端上传的数据
    std::vector<unsigned char> cli_secret;  // 保存客户端计算的密钥
    std::vector<unsigned char> svr_secret;  // 保存服务器计算的密钥

    // step 1 - 服务器: make private key and public key
    CASE_EXPECT_EQ(0, svr_dh.make_params(switch_params));

    // step 2 - 客户端: read dhparam and public key of server
    CASE_EXPECT_EQ(0, cli_dh.read_params(switch_params.data(), switch_params.size()));

    // step 3 - 客户端: make public key
    CASE_EXPECT_EQ(0, cli_dh.make_public(switch_public));

    // step 4 - 客户端: calculate secret
    CASE_EXPECT_EQ(0, cli_dh.calc_secret(cli_secret));

    // step 5 - 服务器: read public key of client
    CASE_EXPECT_EQ(0, svr_dh.read_public(switch_public.data(), switch_public.size()));

    // step 6 - 服务器: calculate secret
    CASE_EXPECT_EQ(0, svr_dh.calc_secret(svr_secret));

    // DH process done
    CASE_EXPECT_EQ(cli_secret.size(), svr_secret.size());
    if (cli_secret.size() == svr_secret.size()) {
        CASE_EXPECT_EQ(0, memcmp(cli_secret.data(), svr_secret.data(), svr_secret.size()));
    }
}
```

[1]: https://github.com/atframework/atframe_utils
[2]: https://github.com/atframework/atsf4g-co/tree/master/atframework/service/atgateway
[3]: https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman
[4]: https://tools.ietf.org/html/rfc4492
[5]: https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange
[6]: https://en.wikipedia.org/wiki/XXTEA
[7]: https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
[8]: https://www.openssl.org/
[9]: https://tls.mbed.org/
[10]: https://github.com/atframework/atframe_utils/blob/master/include/algorithm/crypto_cipher.h